<<<
:sectnums:
=== Bootloader

The NEORV32 bootloader (`sw/bootloader/bootloader.c`) provides an optional built-in firmware that allows to upload
new application firmware at any time without the need to re-synthesize the FPGA's bitstream. A UART connection
is used to provide an interactive user interface that allows to upload executables. Furthermore, the bootloader
provides a programmer to write an executable to a processor-external serial flash. The bootloader's auto-boot feature
can optionally load and boot this executable right after reset. The NEORV32 bootloader is enabled via the
<<_boot_configuration>> `BOOT_MODE_SELECT` generic.

.Pre-Built Bootloader Image
[NOTE]
This section refers to the **default** NEORV32 bootloader. The <<_bootloader_rom_bootrom>> image file
(`rtl/core/neorv32_bootloader_image.vhd`) already contains the pre-compiled bootloader in its default configuration.

.Minimal Hardware Requirements
[NOTE]
The default bootloader image was compiled for a minimal `rv32e_zicsr_zifencei` ISA configuration and requires a
RAM (DMEM) size of at least 256 bytes. These constraints ensure that the bootloader can be executed on any
CPU/processor configuration. It is recommended to enable at least the UART0, CLINT and GPIO processor modules
for the _intuitive_ bootloader features.

.Bootloader Customization and Additional Features
[TIP]
Most parts of the bootloader can be customized (for example the auto-boot timeout, the actual LED pin, the SPI clock
speed, etc.). Additionally, an **TWI/IÂ²C boot** option is available, which is disabled by default. The bootloader is
customized by editing the _defines_ in a single C header file (`config.h`). See the User Guide
https://stnolting.github.io/neorv32/ug/#_customizing_the_internal_bootloader for more information.


:sectnums:
==== Bootloader Console

The default bootloader provides a serial console via UART0 for user interaction using the following terminal
settings (`19200-8-N-1`):

* 19200 Baud
* 8 data bits
* no parity bit
* 1 stop bit
* newlines are `\r\n`
* no transfer/control protocol

.Terminal Program
[TIP]
Any terminal program that can connect to a serial port should work. However, make sure the program can transfer data
in _raw_ byte mode without any protocol overhead (e.g. XMODEM). Some terminal programs struggle with transmitting files
larger than 4kB (see https://github.com/stnolting/neorv32/pull/215). Try a different terminal program if uploading of
a binary does not work.

The bootloader uses the LSB of the top entity's GPIO output port (`gpio_o(0)`) for an high-active status LED. All other
output pins are set to low. After reset, the status LED will start blinking at 2Hz and the splash screen shows up and
<<_auto_boot_sequence>> is started. This auto-boot sequence can be skipped within 10s by pressing any key (i.e. sending
any char).

.Bootloader Console (with annotations)
[source]
----
NEORV32 Bootloader

BLDV: Mar 30 2025 <1>
HWV:  0x01110202  <2>
CLK:  0x017d7840  <3>
MISA: 0x40801104  <4>
XISA: 0x00000083  <5>
SOC:  0x000f800d  <6>
IMEM: 0x00004000  <7>
DMEM: 0x00002000  <8>

Autoboot in 10s. Press any key to abort. <9>
Aborted. <10>

Available CMDs:         <11>
 h: Help                <12>
 r: Restart             <13>
 u: Upload via UART     <14>
 s: Store to SPI flash  <15>
 l: Load from SPI flash <16>
 e: Start executable    <17>
CMD:> <18>
----
<1> Bootloader version (built date).
<2> Processor hardware version in BCD format (<<_mimpid>> CSR).
<3> Processor clock speed in Hz (`CLK` register of <<_system_configuration_information_memory_sysinfo>>.
<4> RISC-V CPU extensions (<<_misa>> CSR).
<5> NEORV32-specific CPU extensions (<<_mxisa>> CSR).
<6> Processor configuration (`SOC` register of <<_system_configuration_information_memory_sysinfo>>.
<7> Internal IMEM size in byte (`MEM` register of <<_system_configuration_information_memory_sysinfo>>.
<8> Internal DMEM size in byte (`MEM` register of <<_system_configuration_information_memory_sysinfo>>.
<9> Start of <<_auto_boot_sequence>>.
<10> Auto-boot sequence aborted due to user console input.
<11> List of all commands.
<12> Show "Available CMDs" help text again.
<13> Restart bootloader and auto-boot sequence.
<14> Upload new program executable (`neorv32_exe.bin`) via UART.
<15> Store previously-uploaded executable to SPI flash.
<16> Load executable from SPI flash.
<17> Start the (up)loaded executable.
<18> Command prompt.

If the auto-boot countdown is stopped the interactive user console starts. A new executable (`neorv32_exe.bin`) can be
uploaded via UART by executing the `u` command. After that the executable can be booted via the `e` command. To program
the recently uploaded executable to an attached SPI flash press `s`. To load an executable from the SPI flash press `l`.
The bootloader including the auto-boot sequence can be manually restarted at any time via the `r` command.


:sectnums:
==== Auto Boot Sequence

After a reset, the bootloader waits 10 seconds for a UART console input before it starts the automatic boot sequence:

[start=1]
. Try to load an executable from an external SPI flash using chip select `spi_csn_o(0)`.
. If 1 fails, try to load an executable from an external TWI flash at device address `0x50`. Note that this
auto-boot option is disabled by default.
. IF 2 fails, start user console.

If a valid boot image is loaded it will be immediately started.


:sectnums:
==== Bootloader Error Codes

If something goes wrong an error code is shown. In this case the bootloader status LED stops blinking, an error code is printed
to the console and the processor is halted by entering <<_sleep_mode>>.

[cols="<2,<8"]
[grid="rows"]
|=======================
| **`ERROR_DEVICE`**    | A device/flash-accessing function returned an error code. Make sure that the device is properly
connected and that all required processor modules are actually enabled (by the according <<_processor_top_entity_generics>>).
| **`ERROR_SIGNATURE`** | The signature that indicates a valid NEORV32 executable of the loaded executable is incorrect.
This can be caused by a temporary transmission error or by an invalid or corrupted executable.
| **`ERROR_CHECKSUM`**  | The checksum of the loaded executable is incorrect. This can be caused by a temporary transmission
error or by an invalid or corrupted executable.
| **`ERROR_EXCEPTION`** | An unexpected trap (synchronous exception or interrupt) has occurred. This can be caused by an
invalid bootloader configuration (actually available processor modules, memory layout, ...). For debugging purpose the error
message will also display the
|=======================


[cols="^2,<8"]
[grid="none"]
|=======================
| **REQUIRED**  | The <<_boot_configuration>> (`BOOT_MODE_SELECT` generic) has to be set to "bootloader" mode.
| **REQUIRED**  | At least 256 bytes of data memory (processor-internal DMEM or processor-external DMEM) are required for the bootloader's stack and global variables.
| _RECOMMENDED_ | For user interaction via the <<_bootloader_console>> (like uploading executables) the primary UART (<<_primary_universal_asynchronous_receiver_and_transmitter_uart0>>) is required.
| _RECOMMENDED_ | The default bootloader uses bit 0 of the <<_general_purpose_input_and_output_port_gpio>> output port to drive a high-active "heart beat" status LED.
| _RECOMMENDED_ | The machine timer of the <<_core_local_interruptor_clint>> is used to control blinking of the status LED and also to automatically trigger the <<_auto_boot_sequence>>.
| OPTIONAL      | The SPI controller (<<_serial_peripheral_interface_controller_spi>>) is needed to store/load executable from external flash using the <<_auto_boot_sequence>>.
| OPTIONAL      | The TWI controller (<<_two_wire_serial_interface_controller_twi>>) is needed to boot/execute code directly from pre-programmed TWI memory.
|=======================
